## 프로세스 동기화 (by 이찬형)

### 1. 답변

- 프로세스 동기화란 한 프로세스가 작업이 끝나기 전에 다른 프로세스가 동일한 메모리 자원에 접근하고 수정함으로써, 결과가 기대했던대로 나오지 않는 "data race(데이터 경쟁)" 상황을 막기 위한 기법이라고 할 수 있습니다. 세마포어를 이용하여 프로세스 동기화를 구현하는데, 세마포어를 획득하는 함수 호출과 반납하는 함수 호출 사이의 코드를 임계 영역(critical section)이라고 합니다. 세마포어를 획득한(즉, 임계 영역에 들어간) 프로세스는 세마포어를 반납할 때(즉, 임계 영역을 빠져나갈 때)까지 다른 프로세스가 임계 영역안에 있는 자원을 사용하지 못하도록 보장받을 수 있습니다. 다시 말해서, 동일한 메모리 자원에 단 하나의 프로세스만 접근할 수 있게 보장함으로써 데이터 경쟁이 발생하지 않고 멀티 프로세스 환경에서도 기대했던 결과를 얻을 수 있습니다.

### 2. 정리

- 병렬 처리를 위해 멀티 프로세스(쓰레드) 환경을 사용한다. 프로그램을 더 빠르게 실행하게 만드는 자연스럽고 전형적인 방법이다. 명령어의 실행 순서에 따라 결과가 달라지는 상황을 경쟁 조건(race condition) 이라고 혹은 더 구체적으로 데이터 경쟁(data race) 이라고 부른다. 멀티 쓰레드가 같은 코드를 실행할 때 경쟁 조건이 발생하기 때문에 이러한 코드 부분을 임계 영역(critical section) 이라고 부른다. 공유 자원에 접근하고 하나 이상의 쓰레드에서 동시에 실행되면 안 되는 코드를 임계 영역이라 부른다. 이러한 코드에서 필요한 것은 상호 배제(mutual exclusion) 이다. 이 속성은 하나의 쓰레드가 임계 영역 내의 코드를 실행 중일 때는 다른 쓰레드가 실행할 수 없도록 보장해 준다. 즉, 동기화가 필요하다. 임계 영역 문제에 대한 해결 방법 중 하나로 강력한 명령어 한 개로 의도한 동작을 수행하여, 인터럽트 발생 가능성을 원천적으로 차단하는 것이다. 하드웨어 지원을 사용하고 운영 체제의 도움을 받아 한번에 하나의 쓰레드만 임계 영역에서 실행하도록 구성된, "제대로 잘 작동하는" 멀티 쓰레드 프로그램을 작성할 수 있다.

- 락은 프로그래머에게 스케줄링에 대한 최소한의 제어권을 제공한다. 락은 쓰레드에 대한 제어권을 일부 이양 받을 수 있도록 해준다. 프로그래머는 그 코드 내에서는 하나의 쓰레드만 동작하도록 보장할 수 있게 하여 어느 정도 질서를 부여할 수 있다.

  - 초창기 락은 상호 배제 지원을 위해 1) 임계 영역 내에서는 인터럽트를 비활성화하는 방법을 사용했었다. 타이머 인터럽트 등이 발생하지 않으므로 다른 쓰레드가 끼어들지 않는 다는 것을 보장할 수 있다. 하지만 나쁜 목적을 가진 응용 프로그램이 CPU를 독점할 수 있어 시스템 제어권을 다시 얻을 수 없는 문제가 발생할 수 있다.
  - 그 다음은 2) 기존 load / store 명령어만을 활용한 방법이다. 이 경우에는 원자성이 보장되지 않기 때문에 락으로 사용할 수 없고, spin-wait 방법을 사용하면 성능상 비효율적인 단점이 있다. 피터슨 알고리즘이라고 load / store 명령어만을 활용한 소프트웨어 락을 구현하였지만 하드웨어로부터 약간의 지원을 받으면 훨씬 쉽게 해결할 수 있다는 것을 알게 된 후로 필요가 없게 되었다.
  - 그 다음은 3) 하드웨어가 원자성이 보장되는 명령어를 지원한다는 가정 하에 소프트웨어 락을 구현하는 것이다. TestAndSet 등과 같은 명령어를 사용하면, 이전 값을 "검사(test)"하는 동시에 메모리에 새로운 값을 "설정(set)" 할 수 있다.

- 락을 이용하여 하나의 쓰레드만 임계 영역에 진입할 수 있다고 하였다. 그렇다면 진입한 쓰레드를 제외한 나머지 쓰레드는 어떤 방식으로 기다려야 하는가?

  - 1.  busy-wait : CPU 시간을 차지하면서 의미없는 기다림을 한다.
  - 2.  yield : yield 시스템 콜은 쓰레드 상태를 running -> ready 상태로 변환하게 한다. 즉, CPU를 즉시 반납하여 스케줄러에서 자신을 deschedule 하는 것이다. CPU 시간 차지 문제는 해결하였지만 아직 문맥 교환을 한다는 점에서 비효율적이다. 또한, 순서의 개념이 존재하지 않기 떄문에 여전히 기아 현상이 발생한다.
  - 3.  sleep : 락 대기자 전용 큐를 만들고, 기다리는 쓰레드를 sleep(blocked 상태)하도록 만드는 방법이다. 위의 문제를 모두 해결하긴 하지만, 교착 상태(wakeup/waiting race)라는 새로운 문제가 등장한다.

### 3. 고쳐야 할 점

- 용어

  - 동일한 메모리 자원 => 공유 자원 : 조금 더 명확한 어휘 선택 및 간결하게 전달
  - 접근하고 수정함으로써 => 접근하여 그 값을 변경하려고 : 어휘 선택

- 데이터 경쟁에 대한 조금 더 자세한 설명이 필요

  - 데이터 경쟁은 두 개 이상의 프로세스나 스레드가 동시에 공유된 자원에 접근하여 그 값을 변경하려고 할 때 발생하는 문제를 의미

- 프로세스 동기화를 사용할 때의 이점에 대한 설명이 약간 부족

  - 1. 자원을 안전하게 공유(데이터 경쟁 문제를 해결할 수 있음, 예측 가능함)
  - 2. 전체적인 시스템 안정성과 성능을 높일 수 있음 : 멀티 프로세스 환경을 가능하게 함. 멀티 프로세스 환경의 장점(성능을 높일 수 있음)

- 세마포어 매커니즘 설명 부재

  - 소프트웨어 락의 한계 및 하드웨어 지원(cf. 피터슨 알고리즘?) : 소프트웨어적으로 락을 걸기 위해서는 조건문이 필요하다. 조건문에서 현재 들어갈 수 있는 flag가 true인지를 확인하고, 조건문 내부에서 flag를 false로 바꿔야 하는 두 단계 작업이 필요하다. 첫 번째 프로세스가 조건문에서 true로 평가되어 조건문 내부로 들어옴과 동시에 문맥 교환이 발생하였고, 두 번째 프로세스도 조건문 코드를 실행하는 상황에서 첫 번째 프로세스는 아직 flag를 false로 바꾸지 않았으므로 두 번째 프로세스도 조건문 내부로 들어올 수 있다. 조건문 만으로는 제대로 된 락을 구현할 수 없다. flag 값을 확인하는 동시에 값을 바꾸는 원자적인 명령어(instruction) 지원을 받아서 락을 구현할 수 있었다. 피터슨 알고리즘을 통해 소프트웨어적으로도 락을 구현할 수는 있으나 하드웨어로부터 약간의 지원을 받으면 훨씬 쉽게 해결할 수 있다는 것을 알게 된 후로 필요가 없게 되었다
  - busy-wait vs. sleep : 효율성의 관점. 예를 들어, 프로세스가 10개일 때 하나의 프로세스만 임계 영역에 들어갔다고 가정해보자. busy-wait은 나머지 9개의 프로세스가 CPU 시간을 소모하면서 임계 영역에 들어간 프로세스가 끝나기를 기다린다. 즉, 10 단위 시간만에 임계 영역에 있는 프로세스가 다시 코드를 실행할 수 있게 된다. 의미 없이 CPU 시간을 소모하면서 문맥 교환 또한 일어난다. 프로세스가 많아지면 많아질수록 시스템은 느려지게 되는 확장성 문제가 발생한다. 반면, sleep은 나머지 9개 프로세스를 blocked 상태로 만듦으로써 CPU 시간을 소모하지 않게 한다. 임계 영역에 있는 프로세스는 더 빨리 CPU를 획득할 수 있다. 임계 영역 프로세스가 작업이 끝나면, blocked 상태로 기다리고 있는 9개의 프로세스를 차례로 깨운다. 이와 같은 방식으로 관리를 하면, 기다리는 나머지 프로세스들은 CPU 시간을 소모하지 않는 상태에서 문맥 교환도 더 적게 발생하기 때문에 성능 상의 이점을 얻을 수 있다.

- 나의 개요

  - 1. 소개

    - 프로세스 동기화의 뜻과 목적

  - 2. 세부 설명

    - 데이터 경쟁, 임계 영역에 대한 단어 소개
    - 세마포어를 사용하여 문제 해결 및 얻을 수 있는 효과

  - 3. 요약

    - 위에서 발생한 문제를 해결하고, 특정 효과를 얻을 수 있다

  - 프로세스 동기화가 발생하는 배경을 추가하면 좋을 것 같다 : 병렬 처리
  - 프로세스 동기화로 인해 발생하는 문제를 명확히 분리하지 않았다 : "데이터 경쟁이라는 문제"라고 확실히 말하면 더 명확해질 것 같다
  - 해결 방법으로서의 프로세스 동기화라고 명확히 말히지 않았다
  - 장단점을 명확히 구분하지 않았다
  - 구조 : 프로세스 동기화 뜻과 목적(간략) => 데이터 경쟁 문제 소개 => 해결 방법으로서의 프로세스 동기화 소개 => 프로세스 동기화의 장단점 소개

- 개요 피드백

  - 1. 개요 소개

    - 프로세스 동기화는 무엇인가?
    - 프로세스 동기화의 중요성과 목적(왜 필요한가?)

  - 2. 문제 설명

    - (멀티 프로세스 기법에 대한 소개)
    - 데이터 경쟁(data race)이란 무엇인지 설명

  - 3. 해결 방법 소개

    - 프로세스 동기화를 통해 데이터 경쟁 문제를 해결할 수 있다고 설명
    - 세마포어, 뮤텍스, 모니터 등의 동기화 도구를 소개하고 각각의 역할과 특징을 간단히 설명

  - 4. 세부 설명

    - 세마포어나 뮤텍스 등의 구체적인 동기화 메커니즘에 대해 설명
    - 임계 영역(critical section)에 대한 개념과 중요성을 강조
    - 각 동기화 도구를 어떻게 사용하는지, 잠금 획득과 해제의 과정을 설명

  - 5. 장단점과 응용

    - 프로세스 동기화를 통해 얻을 수 있는 장점을 설명합니다. (예: 자원 공유의 안정성, 시스템의 일관성 유지 등)
    - 동기화 도구를 잘 활용함으로써 발생할 수 있는 성능 향상 등의 장점을 언급합니다.
    - 단점 : 교착 상태 문제, 복잡한 함수 및 코드로 인한 실수 등이 발생할 수 있다.

  - 6. 마무리

    - 한 문장으로 요약

### 4. keyword

- 공유 자원
- 데이터 경쟁
- 임계 영역
- 접근 및 변경
- 잠금(락)
- 자원 공유의 안정성
- 시스템 일관성 유지
- 성능 향상
- 멀티 프로세싱
- 세마포어(뮤텍스)
