## 동기와 비동기의 차이 (by 이찬형)

### 1. 답변

- 동기와 비동기를 나누는 기준은 일련의 작업들을 처리할 순서를 어떻게 지정하는가입니다. 동기는 이전 작업이 완전히 끝나면, 다음 작업을 실행합니다. 반면, 비동기는 이전 작업이 완전히 끝나지 않아도, 다음 작업을 실행할 수 있도록 하는 것입니다. 그래서 작업을 동기로 처리하는 경우에는 이전 작업의 끝이 다음 작업의 시작과 같습니다. 작업을 비동기로 처리한다면, 이전 작업의 끝과 다음 작업의 시작은 반드시 같지 않습니다. 따라서 일련의 작업들의 순서가 중요한 경우에는 동기로 처리해야 하는 것이 좋고, 순서가 중요하지 않은 경우에는 비동기로 처리할 수 있습니다. 예를 들어, 치킨과 피자를 각각 배달시키려고 하는 경우에 매장에 주문을 하고, 매장에서 요리를 하고, 집으로 배달을 시키는 각각의 작업은 순서가 중요하기 때문에 동기적인 방식으로 처리해야 합니다. 하지만 반드시 치킨 주문을 끝낸 다음에 피자 주문을 해야할 필요는 없기 때문에 두 사람이 비동기적인 방식으로 처리할 수 있습니다. 이렇게 볼 때, 동기적인 작업은 시작과 끝이 반드시 이어져야 하므로, 앞의 작업이 예상치 못한 지연이 발생한다면 뒤의 모든 작업은 영향을 받을 수 밖에 없습니다. 즉, 융통적이지 않고, 총 작업 시간이 상대적으로 길다는 장점이 있습니다. 대신 작업을 처리하는 방식이 단순하고 작업의 흐름 예측 및 디버깅이 쉽다는 장점이 있습니다. 반면, 비동기적인 작업은 작업 간에 영향을 거의 주지 않기 때문에 병목이 발생하지 않아, 총 작업 시간이 상대적으로 짧다는 장점이 있습니다. 대신 작업을 처리하는 방식이 복잡하고 작업의 흐름 예측 및 디버깅이 어렵다는 단점이 있습니다.

- 비동기적인 작업을 효율적으로 처리하는 대표적인 방법은 이벤트 기반의 방식입니다. polling 방식은 매번 작업이 종료되었는지를 확인하는 절차가 필요하므로 비효율적이빈다. 반면, 끝난 작업들을 이벤트로 받아 차례대로 처리하는 방식을 이용하면 불필요한 확인 절차를 줄일 수 있어 훨씬 효율적입니다.

- 이와 연관된 개념으로 블로킹과 논블로킹이 있습니다. 이 개념은 커널과 프로세스 관계에서, 커널 작업(보통 I/O 작업)이 모두 끝날 때까지 제어권 없이 프로세스가 대기할 것인지, 커널 작업이 모두 끝나지 않더라도 제어권을 즉시 얻을 것인지에 대한 선택입니다. 전자는 프로세스가 아무 작업도 하지 못하는 blocked 상태로 대기하는 대신, 제어권을 다시 얻을 때 완전한 작업 결과를 확인할 수 있습니다. 후자는 프로세스가 즉시 제어권을 받아 다른 작업을 할 수 있는 상태인데 반해, 제어권을 다시 얻을 때 작업이 완전히 끝나지 않았을 수도 있다는 것을 염두에 두어야 합니다. 블로킹의 장점은 로직이 단순해서 구현이 비교적 쉽다는 장점이 있는 반면, 응답성이 저하될 수 있는 단점이 있습니다. 논블로킹의 장점은 오래 걸리는 작업이 있어도 응답성이 높은 반면, 구현에 복잡하다는 단점이 있습니다.

### 2. 정리

- 동기 작업은 작업의 시작과 끝이 서로 연결되어 있습니다. 반면, 비동기 작업은 작업의 시작과 끝이 서로 연결되어 있지 않습니다. 동기 작업은 순차적으로 실행되고 서로 의존하며, 비동기 작업은 병렬적으로 실행되고 서로 의존하지 않습니다.

- 동기 작업은 가장 단순한 방법으로 실행하고 싶은 순서대로 코드를 나열하면 된다. 반면, 비동기 작업은 코드의 실행 순서나 시간의 흐름을 예측하기 어렵다.

- 비동기 작업을 실행하는 방법으로 크게 두 가지 방법이 있다. 첫 번째는 프로세스(또는 쓰레드)를 생성하는 방법이고, 두 번째는 이벤트 기반 구조를 사용하는 방법이다.
- 첫 번째 방법은 1) 프로세스 동기화 문제가 있다. 여러 프로세스가 서로 공유 자원에 동시에 접근하여 값을 변경하여, 기대한대로 동작하지 않는(결정론적인 결과를 얻지 못하는) 문제를 말한다. 또한, 병행 프로세스를 동기적으로 처리해야 하는 경우에는 2) 특정 프로세스를 기다려야하고, 다른 프로세스는 적절하게 자원을 회수해야 하는 또 다른 문제가 발생한다.

  - (26) 병행성: 개요 (27) 막간: 쓰레드 API (28) 락 (29) 락 기반의 병행 자료 구조 (30) 컨디션 변수 (31) 세마포어 (32) 병행성 관련 버그

- 두 번째 방법은 첫 번째 방법이 가진 문제점을 해결할 수 있다. 1) 어려움 2) 운영 체제가 CPU 스케줄링에 대한 전권을 갖는다는 문제이다. 이벤트 기반의 병행성은 1) 특정 사건（이벤트）의 발생을 대기한다 2) 사건이 발생하면, 사건（이벤트）의 종류를 파악한 후, I/O을 요청하거나 추후 처리를 위하여 다른 이벤트를 발생시키거나 하는 등의 작업을 하는 순서로 진행된다. 이벤트를 처리하는 과정이 스케줄링과 유사하기 때문에 2)번 문제를 해결할 수 있다. 락이 필요없다는 특징만 있어도 1)번 문제를 대부분 해결할 수 있다. 하지만 치명적인 문제가 있는데 블로킹 시스템 콜은 비동기 방식이 아닌 동기 방식으로 처리된다는 것이다. UNIX에서는 논블로킹 소켓을 통해 바로 제어권을 되돌려받고, 작업 완료(결과)는 인터럽트(시그널) 방식으로 결과를 처리하는 방법으로 해결하였다. 또 다른 문제점으로는 작업을 실행하는 데 필요한 상태(정보)를 관리해야 한다는 것이다. 프로세스 방식에서는 각각의 메모리 영역이 따로 존재하였으나, 이벤트 방식에서는 그렇지 않다. 처리할 때 필요한 정보를 관리할 방법이 필요하다.

  - (33) 이벤트 기반의 병행성

- webserv 과제
  - I/O multiplexing 함수 : 비동기 블로킹 / 논블로킹(옵션에 따라)
  - 소켓 I/O(recv, send) : 비동기 논블로킹
  - 파일 시스템 I/O(read, write) : 동기 블로킹

### 3. 고쳐야 할 점

- 블로킹, 논블로킹 장단점 누락

- 실제 사용 사례의 예시

  - 예를 들어, 파일 다운로드, 네트워크 호출, 이벤트 처리 등의 경우를 들어 설명하면 더욱 명확해질 수 있습니다.

- 동기와 비동기의 장단점 강조

  - 좀 더 명확하게 각각의 장단점을 강조할 수 있습니다
  - 동기의 경우 작업의 순서가 보장되므로 코드가 간단하고 예측 가능하며 디버깅이 쉽다는 장점을 강조할 수 있습니다.
  - 비동기의 경우 병렬 처리가 가능하고 블로킹이 발생하지 않아 응답성이 향상되며, 작업 간의 의존성이 낮아 병목 현상이 발생하지 않는 등의 장점을 강조할 수 있습니다.

- 비동기를 활용한 구조 미언급 : 이벤트 기반의 구조, 특히 Javascript의 이벤트 루프(event loop)

- 구조 : 동기와 비동기를 나누는 기준은 ㅇㅇ이다 => 기준으로 나눈 동기와 비동기에 대한 설명 및 상황 제시 => 예시 => 동기와 비동기 처리의 장단점 소개

- 개요 피드백

  - 1.  서론

    - 동기와 비동기를 나누는 기준 정의
    - 이 두 용어가 프로그래밍 및 시스템 설계에서 어떤 역할을 하는지 간단히 설명

  - 2.  동기적 작업 설명

    - 예시를 들어 파일 읽기/쓰기, 함수 호출 등의 동기적 작업을 설명합니다.

  - 3.  비동기적 작업 설명

    - 예시를 들어 네트워크 호출, 이벤트 처리 등의 비동기적 작업을 설명합니다.
    - 쓰레드 방식과 이벤트 방식이 있다 정도만 설명

  - 4.  동기와 비동기의 장단점

    - 각각의 방식이 언제 어떤 상황에 적합한지에 대해 설명합니다.
    - 동기의 경우 코드의 간결성과 예측 가능성이 뛰어나지만, 비동기의 경우 응답성과 효율성이 높다는 점을 강조합니다.

  - 5.  실제 사용 사례 및 응용

    - 실제로 어떤 상황에서 동기적 또는 비동기적 방식을 선택하는지에 대해 예시를 들어 설명합니다.
    - 동기 : 파일 읽기/쓰기, 함수 호출
    - 비동기 : 병행 처리(쓰레드 방식, 이벤트 방식)

### 4. keyword

- 작업의 완료
- 작업 간의 의존성, 순서
- 예측 가능성
- 응답성 측면
- 병렬 처리
- 이벤트 기반 구조
